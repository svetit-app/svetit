/**
 * Svetit MS Project
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { CcDi } from '../model/cc-di';
// @ts-ignore
import { CcDis } from '../model/cc-dis';
// @ts-ignore
import { CcModeType } from '../model/cc-mode-type';
// @ts-ignore
import { CcModeTypes } from '../model/cc-mode-types';
// @ts-ignore
import { CcParam } from '../model/cc-param';
// @ts-ignore
import { CcParams } from '../model/cc-params';
// @ts-ignore
import { CcStatusCategories } from '../model/cc-status-categories';
// @ts-ignore
import { CcStatusCategory } from '../model/cc-status-category';
// @ts-ignore
import { CcStatusType } from '../model/cc-status-type';
// @ts-ignore
import { CcStatusTypes } from '../model/cc-status-types';
// @ts-ignore
import { CcType } from '../model/cc-type';
// @ts-ignore
import { CcTypeDiType } from '../model/cc-type-di-type';
// @ts-ignore
import { CcTypeDiTypes } from '../model/cc-type-di-types';
// @ts-ignore
import { CcTypeParam } from '../model/cc-type-param';
// @ts-ignore
import { CcTypeParams } from '../model/cc-type-params';
// @ts-ignore
import { CcTypes } from '../model/cc-types';
// @ts-ignore
import { Code } from '../model/code';
// @ts-ignore
import { Codes } from '../model/codes';
// @ts-ignore
import { ControlCircuit } from '../model/control-circuit';
// @ts-ignore
import { ControlCircuits } from '../model/control-circuits';
// @ts-ignore
import { Device } from '../model/device';
// @ts-ignore
import { DeviceItem } from '../model/device-item';
// @ts-ignore
import { DeviceItems } from '../model/device-items';
// @ts-ignore
import { DevicePluginParam } from '../model/device-plugin-param';
// @ts-ignore
import { Devices } from '../model/devices';
// @ts-ignore
import { DiPluginParam } from '../model/di-plugin-param';
// @ts-ignore
import { DiPluginParams } from '../model/di-plugin-params';
// @ts-ignore
import { DiType } from '../model/di-type';
// @ts-ignore
import { DiTypes } from '../model/di-types';
// @ts-ignore
import { Measure } from '../model/measure';
// @ts-ignore
import { Measures } from '../model/measures';
// @ts-ignore
import { ParamType } from '../model/param-type';
// @ts-ignore
import { ParamTypes } from '../model/param-types';
// @ts-ignore
import { Plugin } from '../model/plugin';
// @ts-ignore
import { Plugins } from '../model/plugins';
// @ts-ignore
import { Project } from '../model/project';
// @ts-ignore
import { ProjectParam } from '../model/project-param';
// @ts-ignore
import { ProjectParams } from '../model/project-params';
// @ts-ignore
import { Projects } from '../model/projects';
// @ts-ignore
import { SaveTimer } from '../model/save-timer';
// @ts-ignore
import { SaveTimers } from '../model/save-timers';
// @ts-ignore
import { Section } from '../model/section';
// @ts-ignore
import { SectionParam } from '../model/section-param';
// @ts-ignore
import { SectionParams } from '../model/section-params';
// @ts-ignore
import { Sections } from '../model/sections';
// @ts-ignore
import { Translation } from '../model/translation';
// @ts-ignore
import { Translations } from '../model/translations';
// @ts-ignore
import { ValueView } from '../model/value-view';
// @ts-ignore
import { ValueViews } from '../model/value-views';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import {
    ProjectServiceInterface
} from './project.serviceInterface';



@Injectable({
  providedIn: 'root'
})
export class ProjectService implements ProjectServiceInterface {

    protected basePath = 'https://svetit-io/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;
            if (firstBasePath != undefined) {
                basePath = firstBasePath;
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Delete Cc Di
     * @param ccId Cc identifier
     * @param diId Di identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcDiDelete(ccId: number, diId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcDiDelete(ccId: number, diId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcDiDelete(ccId: number, diId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcDiDelete(ccId: number, diId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ccId === null || ccId === undefined) {
            throw new Error('Required parameter ccId was null or undefined when calling handlerCcDiDelete.');
        }
        if (diId === null || diId === undefined) {
            throw new Error('Required parameter diId was null or undefined when calling handlerCcDiDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcDiDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcDiDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcDiDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ccId !== undefined && ccId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccId, 'ccId');
        }
        if (diId !== undefined && diId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>diId, 'diId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-di`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Cc Di
     * @param ccId Cc identifier
     * @param diId Di identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcDiGet(ccId: number, diId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcDi>;
    public handlerCcDiGet(ccId: number, diId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcDi>>;
    public handlerCcDiGet(ccId: number, diId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcDi>>;
    public handlerCcDiGet(ccId: number, diId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ccId === null || ccId === undefined) {
            throw new Error('Required parameter ccId was null or undefined when calling handlerCcDiGet.');
        }
        if (diId === null || diId === undefined) {
            throw new Error('Required parameter diId was null or undefined when calling handlerCcDiGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcDiGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcDiGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcDiGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ccId !== undefined && ccId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccId, 'ccId');
        }
        if (diId !== undefined && diId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>diId, 'diId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-di`;
        return this.httpClient.request<CcDi>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Cc Dis
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccId Cc identifier
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcDiListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcDis>;
    public handlerCcDiListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcDis>>;
    public handlerCcDiListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcDis>>;
    public handlerCcDiListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerCcDiListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerCcDiListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcDiListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcDiListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcDiListGet.');
        }
        if (ccId === null || ccId === undefined) {
            throw new Error('Required parameter ccId was null or undefined when calling handlerCcDiListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (ccId !== undefined && ccId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccId, 'ccId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-di/list`;
        return this.httpClient.request<CcDis>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Cc Di
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccDi 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcDiPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccDi: CcDi, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcDiPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccDi: CcDi, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcDiPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccDi: CcDi, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcDiPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccDi: CcDi, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcDiPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcDiPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcDiPost.');
        }
        if (ccDi === null || ccDi === undefined) {
            throw new Error('Required parameter ccDi was null or undefined when calling handlerCcDiPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-di`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccDi,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Cc Mode Type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcModeTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcModeTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcModeTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcModeTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCcModeTypeDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcModeTypeDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcModeTypeDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcModeTypeDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-mode-type`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Cc Mode Type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcModeTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcModeType>;
    public handlerCcModeTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcModeType>>;
    public handlerCcModeTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcModeType>>;
    public handlerCcModeTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCcModeTypeGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcModeTypeGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcModeTypeGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcModeTypeGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-mode-type`;
        return this.httpClient.request<CcModeType>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all CC mode types
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccTypeId CC Type Id for filtering
     * @param projectId ProjectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcModeTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId?: number, projectId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcModeTypes>;
    public handlerCcModeTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId?: number, projectId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcModeTypes>>;
    public handlerCcModeTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId?: number, projectId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcModeTypes>>;
    public handlerCcModeTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId?: number, projectId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerCcModeTypeListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerCcModeTypeListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcModeTypeListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcModeTypeListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcModeTypeListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (ccTypeId !== undefined && ccTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccTypeId, 'ccTypeId');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-mode-type/list`;
        return this.httpClient.request<CcModeTypes>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Cc Mode Type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccModeType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcModeTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccModeType: CcModeType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcModeTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccModeType: CcModeType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcModeTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccModeType: CcModeType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcModeTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccModeType: CcModeType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcModeTypePatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcModeTypePatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcModeTypePatch.');
        }
        if (ccModeType === null || ccModeType === undefined) {
            throw new Error('Required parameter ccModeType was null or undefined when calling handlerCcModeTypePatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-mode-type`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccModeType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Cc Mode Type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccModeType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcModeTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccModeType: CcModeType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcModeTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccModeType: CcModeType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcModeTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccModeType: CcModeType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcModeTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccModeType: CcModeType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcModeTypePost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcModeTypePost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcModeTypePost.');
        }
        if (ccModeType === null || ccModeType === undefined) {
            throw new Error('Required parameter ccModeType was null or undefined when calling handlerCcModeTypePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-mode-type`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccModeType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Cc Param
     * @param ccId Cc identifier
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcParamDelete(ccId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcParamDelete(ccId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcParamDelete(ccId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcParamDelete(ccId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ccId === null || ccId === undefined) {
            throw new Error('Required parameter ccId was null or undefined when calling handlerCcParamDelete.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerCcParamDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcParamDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcParamDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcParamDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ccId !== undefined && ccId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccId, 'ccId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-param`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Cc Param
     * @param ccId Cc identifier
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcParamGet(ccId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcParam>;
    public handlerCcParamGet(ccId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcParam>>;
    public handlerCcParamGet(ccId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcParam>>;
    public handlerCcParamGet(ccId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ccId === null || ccId === undefined) {
            throw new Error('Required parameter ccId was null or undefined when calling handlerCcParamGet.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerCcParamGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcParamGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcParamGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcParamGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ccId !== undefined && ccId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccId, 'ccId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-param`;
        return this.httpClient.request<CcParam>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Cc Params
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccId Cc identifier
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcParams>;
    public handlerCcParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcParams>>;
    public handlerCcParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcParams>>;
    public handlerCcParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerCcParamListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerCcParamListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcParamListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcParamListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcParamListGet.');
        }
        if (ccId === null || ccId === undefined) {
            throw new Error('Required parameter ccId was null or undefined when calling handlerCcParamListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (ccId !== undefined && ccId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccId, 'ccId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-param/list`;
        return this.httpClient.request<CcParams>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Cc Param
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccParam 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccParam: CcParam, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccParam: CcParam, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccParam: CcParam, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccParam: CcParam, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcParamPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcParamPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcParamPost.');
        }
        if (ccParam === null || ccParam === undefined) {
            throw new Error('Required parameter ccParam was null or undefined when calling handlerCcParamPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-param`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccParam,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Cc Status Category
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusCategoryDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcStatusCategoryDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcStatusCategoryDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcStatusCategoryDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCcStatusCategoryDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusCategoryDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusCategoryDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusCategoryDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-category`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Cc Status Category
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusCategoryGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcStatusCategory>;
    public handlerCcStatusCategoryGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcStatusCategory>>;
    public handlerCcStatusCategoryGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcStatusCategory>>;
    public handlerCcStatusCategoryGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCcStatusCategoryGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusCategoryGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusCategoryGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusCategoryGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-category`;
        return this.httpClient.request<CcStatusCategory>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all CC status categories
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusCategoryListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcStatusCategories>;
    public handlerCcStatusCategoryListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcStatusCategories>>;
    public handlerCcStatusCategoryListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcStatusCategories>>;
    public handlerCcStatusCategoryListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerCcStatusCategoryListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerCcStatusCategoryListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusCategoryListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusCategoryListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusCategoryListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerCcStatusCategoryListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-category/list`;
        return this.httpClient.request<CcStatusCategories>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Cc Status Category
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccStatusCategory 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusCategoryPatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusCategory: CcStatusCategory, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcStatusCategoryPatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusCategory: CcStatusCategory, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcStatusCategoryPatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusCategory: CcStatusCategory, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcStatusCategoryPatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusCategory: CcStatusCategory, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusCategoryPatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusCategoryPatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusCategoryPatch.');
        }
        if (ccStatusCategory === null || ccStatusCategory === undefined) {
            throw new Error('Required parameter ccStatusCategory was null or undefined when calling handlerCcStatusCategoryPatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-category`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccStatusCategory,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Cc Status Category
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccStatusCategory 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusCategoryPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusCategory: CcStatusCategory, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcStatusCategoryPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusCategory: CcStatusCategory, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcStatusCategoryPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusCategory: CcStatusCategory, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcStatusCategoryPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusCategory: CcStatusCategory, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusCategoryPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusCategoryPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusCategoryPost.');
        }
        if (ccStatusCategory === null || ccStatusCategory === undefined) {
            throw new Error('Required parameter ccStatusCategory was null or undefined when calling handlerCcStatusCategoryPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-category`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccStatusCategory,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Cc Status Type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcStatusTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcStatusTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcStatusTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCcStatusTypeDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusTypeDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusTypeDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusTypeDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-type`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Cc Status Type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcStatusType>;
    public handlerCcStatusTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcStatusType>>;
    public handlerCcStatusTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcStatusType>>;
    public handlerCcStatusTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCcStatusTypeGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusTypeGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusTypeGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusTypeGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-type`;
        return this.httpClient.request<CcStatusType>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all CC status types
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccTypeId CC Type Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcStatusTypes>;
    public handlerCcStatusTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcStatusTypes>>;
    public handlerCcStatusTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcStatusTypes>>;
    public handlerCcStatusTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerCcStatusTypeListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerCcStatusTypeListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusTypeListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusTypeListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusTypeListGet.');
        }
        if (ccTypeId === null || ccTypeId === undefined) {
            throw new Error('Required parameter ccTypeId was null or undefined when calling handlerCcStatusTypeListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (ccTypeId !== undefined && ccTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccTypeId, 'ccTypeId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-type/list`;
        return this.httpClient.request<CcStatusTypes>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Cc Status Type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccStatusType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusType: CcStatusType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcStatusTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusType: CcStatusType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcStatusTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusType: CcStatusType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcStatusTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusType: CcStatusType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusTypePatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusTypePatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusTypePatch.');
        }
        if (ccStatusType === null || ccStatusType === undefined) {
            throw new Error('Required parameter ccStatusType was null or undefined when calling handlerCcStatusTypePatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-type`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccStatusType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Cc Status Type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccStatusType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcStatusTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusType: CcStatusType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcStatusTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusType: CcStatusType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcStatusTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusType: CcStatusType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcStatusTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccStatusType: CcStatusType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcStatusTypePost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcStatusTypePost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcStatusTypePost.');
        }
        if (ccStatusType === null || ccStatusType === undefined) {
            throw new Error('Required parameter ccStatusType was null or undefined when calling handlerCcStatusTypePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-status-type`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccStatusType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Cc Type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCcTypeDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Cc Type Di Type
     * @param ccTypeId CC Type Id
     * @param diTypeId Di Type Id
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeDiTypeDelete(ccTypeId: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcTypeDiTypeDelete(ccTypeId: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcTypeDiTypeDelete(ccTypeId: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcTypeDiTypeDelete(ccTypeId: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ccTypeId === null || ccTypeId === undefined) {
            throw new Error('Required parameter ccTypeId was null or undefined when calling handlerCcTypeDiTypeDelete.');
        }
        if (diTypeId === null || diTypeId === undefined) {
            throw new Error('Required parameter diTypeId was null or undefined when calling handlerCcTypeDiTypeDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeDiTypeDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeDiTypeDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeDiTypeDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ccTypeId !== undefined && ccTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccTypeId, 'ccTypeId');
        }
        if (diTypeId !== undefined && diTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>diTypeId, 'diTypeId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type-di-type`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Cc Type Di Type
     * @param ccTypeId CC Type Id
     * @param diTypeId Di Type Id
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeDiTypeGet(ccTypeId: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcTypeDiType>;
    public handlerCcTypeDiTypeGet(ccTypeId: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcTypeDiType>>;
    public handlerCcTypeDiTypeGet(ccTypeId: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcTypeDiType>>;
    public handlerCcTypeDiTypeGet(ccTypeId: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ccTypeId === null || ccTypeId === undefined) {
            throw new Error('Required parameter ccTypeId was null or undefined when calling handlerCcTypeDiTypeGet.');
        }
        if (diTypeId === null || diTypeId === undefined) {
            throw new Error('Required parameter diTypeId was null or undefined when calling handlerCcTypeDiTypeGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeDiTypeGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeDiTypeGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeDiTypeGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ccTypeId !== undefined && ccTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccTypeId, 'ccTypeId');
        }
        if (diTypeId !== undefined && diTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>diTypeId, 'diTypeId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type-di-type`;
        return this.httpClient.request<CcTypeDiType>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Cc Type Di Types
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccTypeId CC Type Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeDiTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcTypeDiTypes>;
    public handlerCcTypeDiTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcTypeDiTypes>>;
    public handlerCcTypeDiTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcTypeDiTypes>>;
    public handlerCcTypeDiTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerCcTypeDiTypeListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerCcTypeDiTypeListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeDiTypeListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeDiTypeListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeDiTypeListGet.');
        }
        if (ccTypeId === null || ccTypeId === undefined) {
            throw new Error('Required parameter ccTypeId was null or undefined when calling handlerCcTypeDiTypeListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (ccTypeId !== undefined && ccTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccTypeId, 'ccTypeId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type-di-type/list`;
        return this.httpClient.request<CcTypeDiTypes>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Cc Type Di Type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccTypeDiType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeDiTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeDiType: CcTypeDiType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcTypeDiTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeDiType: CcTypeDiType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcTypeDiTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeDiType: CcTypeDiType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcTypeDiTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeDiType: CcTypeDiType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeDiTypePost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeDiTypePost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeDiTypePost.');
        }
        if (ccTypeDiType === null || ccTypeDiType === undefined) {
            throw new Error('Required parameter ccTypeDiType was null or undefined when calling handlerCcTypeDiTypePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type-di-type`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccTypeDiType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Cc Type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcType>;
    public handlerCcTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcType>>;
    public handlerCcTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcType>>;
    public handlerCcTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCcTypeGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type`;
        return this.httpClient.request<CcType>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all CC types
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcTypes>;
    public handlerCcTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcTypes>>;
    public handlerCcTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcTypes>>;
    public handlerCcTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerCcTypeListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerCcTypeListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerCcTypeListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type/list`;
        return this.httpClient.request<CcTypes>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Cc Type Param
     * @param ccTypeId CC Type Id
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeParamDelete(ccTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcTypeParamDelete(ccTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcTypeParamDelete(ccTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcTypeParamDelete(ccTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ccTypeId === null || ccTypeId === undefined) {
            throw new Error('Required parameter ccTypeId was null or undefined when calling handlerCcTypeParamDelete.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerCcTypeParamDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeParamDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeParamDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeParamDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ccTypeId !== undefined && ccTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccTypeId, 'ccTypeId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type-param`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Cc Type Param
     * @param ccTypeId CC Type Id
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeParamGet(ccTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcTypeParam>;
    public handlerCcTypeParamGet(ccTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcTypeParam>>;
    public handlerCcTypeParamGet(ccTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcTypeParam>>;
    public handlerCcTypeParamGet(ccTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ccTypeId === null || ccTypeId === undefined) {
            throw new Error('Required parameter ccTypeId was null or undefined when calling handlerCcTypeParamGet.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerCcTypeParamGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeParamGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeParamGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeParamGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ccTypeId !== undefined && ccTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccTypeId, 'ccTypeId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type-param`;
        return this.httpClient.request<CcTypeParam>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Cc Type Param
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccTypeId CC Type Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcTypeParams>;
    public handlerCcTypeParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcTypeParams>>;
    public handlerCcTypeParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcTypeParams>>;
    public handlerCcTypeParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerCcTypeParamListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerCcTypeParamListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeParamListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeParamListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeParamListGet.');
        }
        if (ccTypeId === null || ccTypeId === undefined) {
            throw new Error('Required parameter ccTypeId was null or undefined when calling handlerCcTypeParamListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (ccTypeId !== undefined && ccTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>ccTypeId, 'ccTypeId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type-param/list`;
        return this.httpClient.request<CcTypeParams>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Cc Type Param
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccTypeParam 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypeParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeParam: CcTypeParam, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcTypeParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeParam: CcTypeParam, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcTypeParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeParam: CcTypeParam, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcTypeParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, ccTypeParam: CcTypeParam, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypeParamPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypeParamPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypeParamPost.');
        }
        if (ccTypeParam === null || ccTypeParam === undefined) {
            throw new Error('Required parameter ccTypeParam was null or undefined when calling handlerCcTypeParamPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type-param`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccTypeParam,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Cc Type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccType: CcType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccType: CcType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccType: CcType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, ccType: CcType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypePatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypePatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypePatch.');
        }
        if (ccType === null || ccType === undefined) {
            throw new Error('Required parameter ccType was null or undefined when calling handlerCcTypePatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Cc Type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param ccType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCcTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccType: CcType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCcTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccType: CcType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCcTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccType: CcType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCcTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, ccType: CcType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCcTypePost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCcTypePost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCcTypePost.');
        }
        if (ccType === null || ccType === undefined) {
            throw new Error('Required parameter ccType was null or undefined when calling handlerCcTypePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/cc-type`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: ccType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Code
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCodeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCodeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCodeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCodeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCodeDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCodeDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCodeDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCodeDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/code`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Code
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCodeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Code>;
    public handlerCodeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Code>>;
    public handlerCodeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Code>>;
    public handlerCodeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerCodeGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCodeGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCodeGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCodeGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/code`;
        return this.httpClient.request<Code>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all codes
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCodeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Codes>;
    public handlerCodeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Codes>>;
    public handlerCodeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Codes>>;
    public handlerCodeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerCodeListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerCodeListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCodeListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCodeListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCodeListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerCodeListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/code/list`;
        return this.httpClient.request<Codes>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Code
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param code 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCodePatch(xUser: string, xSpaceId: string, xSpaceRole: string, code: Code, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCodePatch(xUser: string, xSpaceId: string, xSpaceRole: string, code: Code, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCodePatch(xUser: string, xSpaceId: string, xSpaceRole: string, code: Code, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCodePatch(xUser: string, xSpaceId: string, xSpaceRole: string, code: Code, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCodePatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCodePatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCodePatch.');
        }
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling handlerCodePatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/code`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: code,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Code
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param code 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerCodePost(xUser: string, xSpaceId: string, xSpaceRole: string, code: Code, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerCodePost(xUser: string, xSpaceId: string, xSpaceRole: string, code: Code, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerCodePost(xUser: string, xSpaceId: string, xSpaceRole: string, code: Code, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerCodePost(xUser: string, xSpaceId: string, xSpaceRole: string, code: Code, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerCodePost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerCodePost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerCodePost.');
        }
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling handlerCodePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/code`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: code,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Control Circuit
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerControlCircuitDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerControlCircuitDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerControlCircuitDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerControlCircuitDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerControlCircuitDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerControlCircuitDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerControlCircuitDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerControlCircuitDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/control-circuit`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Control Circuit
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerControlCircuitGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ControlCircuit>;
    public handlerControlCircuitGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ControlCircuit>>;
    public handlerControlCircuitGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ControlCircuit>>;
    public handlerControlCircuitGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerControlCircuitGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerControlCircuitGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerControlCircuitGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerControlCircuitGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/control-circuit`;
        return this.httpClient.request<ControlCircuit>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all control circuits
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param sectionId sectionId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerControlCircuitListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, sectionId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ControlCircuits>;
    public handlerControlCircuitListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, sectionId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ControlCircuits>>;
    public handlerControlCircuitListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, sectionId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ControlCircuits>>;
    public handlerControlCircuitListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, sectionId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerControlCircuitListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerControlCircuitListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerControlCircuitListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerControlCircuitListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerControlCircuitListGet.');
        }
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling handlerControlCircuitListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (sectionId !== undefined && sectionId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sectionId, 'sectionId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/control-circuit/list`;
        return this.httpClient.request<ControlCircuits>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Control Circuit
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param controlCircuit 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerControlCircuitPatch(xUser: string, xSpaceId: string, xSpaceRole: string, controlCircuit: ControlCircuit, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerControlCircuitPatch(xUser: string, xSpaceId: string, xSpaceRole: string, controlCircuit: ControlCircuit, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerControlCircuitPatch(xUser: string, xSpaceId: string, xSpaceRole: string, controlCircuit: ControlCircuit, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerControlCircuitPatch(xUser: string, xSpaceId: string, xSpaceRole: string, controlCircuit: ControlCircuit, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerControlCircuitPatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerControlCircuitPatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerControlCircuitPatch.');
        }
        if (controlCircuit === null || controlCircuit === undefined) {
            throw new Error('Required parameter controlCircuit was null or undefined when calling handlerControlCircuitPatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/control-circuit`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: controlCircuit,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Control Circuit
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param controlCircuit 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerControlCircuitPost(xUser: string, xSpaceId: string, xSpaceRole: string, controlCircuit: ControlCircuit, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerControlCircuitPost(xUser: string, xSpaceId: string, xSpaceRole: string, controlCircuit: ControlCircuit, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerControlCircuitPost(xUser: string, xSpaceId: string, xSpaceRole: string, controlCircuit: ControlCircuit, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerControlCircuitPost(xUser: string, xSpaceId: string, xSpaceRole: string, controlCircuit: ControlCircuit, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerControlCircuitPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerControlCircuitPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerControlCircuitPost.');
        }
        if (controlCircuit === null || controlCircuit === undefined) {
            throw new Error('Required parameter controlCircuit was null or undefined when calling handlerControlCircuitPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/control-circuit`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: controlCircuit,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Device
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDeviceDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDeviceDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDeviceDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDeviceDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerDeviceDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDeviceDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDeviceDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDeviceDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Device
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDeviceGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Device>;
    public handlerDeviceGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Device>>;
    public handlerDeviceGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Device>>;
    public handlerDeviceGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerDeviceGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDeviceGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDeviceGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDeviceGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device`;
        return this.httpClient.request<Device>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Device Item
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDeviceItemDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDeviceItemDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDeviceItemDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDeviceItemDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerDeviceItemDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDeviceItemDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDeviceItemDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDeviceItemDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device-item`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Device Item
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDeviceItemGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<DeviceItem>;
    public handlerDeviceItemGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<DeviceItem>>;
    public handlerDeviceItemGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<DeviceItem>>;
    public handlerDeviceItemGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerDeviceItemGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDeviceItemGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDeviceItemGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDeviceItemGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device-item`;
        return this.httpClient.request<DeviceItem>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all device items
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param deviceId Device Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDeviceItemListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, deviceId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<DeviceItems>;
    public handlerDeviceItemListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, deviceId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<DeviceItems>>;
    public handlerDeviceItemListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, deviceId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<DeviceItems>>;
    public handlerDeviceItemListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, deviceId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerDeviceItemListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerDeviceItemListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDeviceItemListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDeviceItemListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDeviceItemListGet.');
        }
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling handlerDeviceItemListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (deviceId !== undefined && deviceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceId, 'deviceId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device-item/list`;
        return this.httpClient.request<DeviceItems>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Device Item
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param deviceItem 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDeviceItemPatch(xUser: string, xSpaceId: string, xSpaceRole: string, deviceItem: DeviceItem, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDeviceItemPatch(xUser: string, xSpaceId: string, xSpaceRole: string, deviceItem: DeviceItem, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDeviceItemPatch(xUser: string, xSpaceId: string, xSpaceRole: string, deviceItem: DeviceItem, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDeviceItemPatch(xUser: string, xSpaceId: string, xSpaceRole: string, deviceItem: DeviceItem, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDeviceItemPatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDeviceItemPatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDeviceItemPatch.');
        }
        if (deviceItem === null || deviceItem === undefined) {
            throw new Error('Required parameter deviceItem was null or undefined when calling handlerDeviceItemPatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device-item`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: deviceItem,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Device Item
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param deviceItem 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDeviceItemPost(xUser: string, xSpaceId: string, xSpaceRole: string, deviceItem: DeviceItem, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDeviceItemPost(xUser: string, xSpaceId: string, xSpaceRole: string, deviceItem: DeviceItem, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDeviceItemPost(xUser: string, xSpaceId: string, xSpaceRole: string, deviceItem: DeviceItem, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDeviceItemPost(xUser: string, xSpaceId: string, xSpaceRole: string, deviceItem: DeviceItem, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDeviceItemPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDeviceItemPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDeviceItemPost.');
        }
        if (deviceItem === null || deviceItem === undefined) {
            throw new Error('Required parameter deviceItem was null or undefined when calling handlerDeviceItemPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device-item`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: deviceItem,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all devices
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDeviceListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Devices>;
    public handlerDeviceListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Devices>>;
    public handlerDeviceListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Devices>>;
    public handlerDeviceListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerDeviceListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerDeviceListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDeviceListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDeviceListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDeviceListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerDeviceListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device/list`;
        return this.httpClient.request<Devices>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Device
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param device 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDevicePatch(xUser: string, xSpaceId: string, xSpaceRole: string, device: Device, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDevicePatch(xUser: string, xSpaceId: string, xSpaceRole: string, device: Device, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDevicePatch(xUser: string, xSpaceId: string, xSpaceRole: string, device: Device, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDevicePatch(xUser: string, xSpaceId: string, xSpaceRole: string, device: Device, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDevicePatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDevicePatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDevicePatch.');
        }
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling handlerDevicePatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: device,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Device Plugin Param
     * @param deviceId Device Id
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDevicePluginParamDelete(deviceId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDevicePluginParamDelete(deviceId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDevicePluginParamDelete(deviceId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDevicePluginParamDelete(deviceId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling handlerDevicePluginParamDelete.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerDevicePluginParamDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDevicePluginParamDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDevicePluginParamDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDevicePluginParamDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (deviceId !== undefined && deviceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceId, 'deviceId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device-plugin-param`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Device Plugin Param
     * @param deviceId Device Id
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDevicePluginParamGet(deviceId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<DevicePluginParam>;
    public handlerDevicePluginParamGet(deviceId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<DevicePluginParam>>;
    public handlerDevicePluginParamGet(deviceId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<DevicePluginParam>>;
    public handlerDevicePluginParamGet(deviceId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling handlerDevicePluginParamGet.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerDevicePluginParamGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDevicePluginParamGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDevicePluginParamGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDevicePluginParamGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (deviceId !== undefined && deviceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceId, 'deviceId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device-plugin-param`;
        return this.httpClient.request<DevicePluginParam>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Device Plugin Param
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param deviceId Device Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDevicePluginParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, deviceId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<CcTypeParam>;
    public handlerDevicePluginParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, deviceId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<CcTypeParam>>;
    public handlerDevicePluginParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, deviceId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<CcTypeParam>>;
    public handlerDevicePluginParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, deviceId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerDevicePluginParamListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerDevicePluginParamListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDevicePluginParamListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDevicePluginParamListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDevicePluginParamListGet.');
        }
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling handlerDevicePluginParamListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (deviceId !== undefined && deviceId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>deviceId, 'deviceId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device-plugin-param/list`;
        return this.httpClient.request<CcTypeParam>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Device Plugin Param
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param devicePluginParam 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDevicePluginParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, devicePluginParam: DevicePluginParam, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDevicePluginParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, devicePluginParam: DevicePluginParam, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDevicePluginParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, devicePluginParam: DevicePluginParam, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDevicePluginParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, devicePluginParam: DevicePluginParam, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDevicePluginParamPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDevicePluginParamPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDevicePluginParamPost.');
        }
        if (devicePluginParam === null || devicePluginParam === undefined) {
            throw new Error('Required parameter devicePluginParam was null or undefined when calling handlerDevicePluginParamPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device-plugin-param`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: devicePluginParam,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Device
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param device 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDevicePost(xUser: string, xSpaceId: string, xSpaceRole: string, device: Device, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDevicePost(xUser: string, xSpaceId: string, xSpaceRole: string, device: Device, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDevicePost(xUser: string, xSpaceId: string, xSpaceRole: string, device: Device, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDevicePost(xUser: string, xSpaceId: string, xSpaceRole: string, device: Device, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDevicePost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDevicePost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDevicePost.');
        }
        if (device === null || device === undefined) {
            throw new Error('Required parameter device was null or undefined when calling handlerDevicePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/device`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: device,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete DI Plugin Param
     * @param diTypeId Di Type Id
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDiPluginParamDelete(diTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDiPluginParamDelete(diTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDiPluginParamDelete(diTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDiPluginParamDelete(diTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (diTypeId === null || diTypeId === undefined) {
            throw new Error('Required parameter diTypeId was null or undefined when calling handlerDiPluginParamDelete.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerDiPluginParamDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDiPluginParamDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDiPluginParamDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDiPluginParamDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (diTypeId !== undefined && diTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>diTypeId, 'diTypeId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/di-plugin-param`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one DI Plugin Param
     * @param diTypeId Di Type Id
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDiPluginParamGet(diTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<DiPluginParam>;
    public handlerDiPluginParamGet(diTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<DiPluginParam>>;
    public handlerDiPluginParamGet(diTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<DiPluginParam>>;
    public handlerDiPluginParamGet(diTypeId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (diTypeId === null || diTypeId === undefined) {
            throw new Error('Required parameter diTypeId was null or undefined when calling handlerDiPluginParamGet.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerDiPluginParamGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDiPluginParamGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDiPluginParamGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDiPluginParamGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (diTypeId !== undefined && diTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>diTypeId, 'diTypeId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/di-plugin-param`;
        return this.httpClient.request<DiPluginParam>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all DI Plugin Param
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param diTypeId Di Type Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDiPluginParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, diTypeId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<DiPluginParams>;
    public handlerDiPluginParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, diTypeId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<DiPluginParams>>;
    public handlerDiPluginParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, diTypeId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<DiPluginParams>>;
    public handlerDiPluginParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, diTypeId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerDiPluginParamListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerDiPluginParamListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDiPluginParamListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDiPluginParamListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDiPluginParamListGet.');
        }
        if (diTypeId === null || diTypeId === undefined) {
            throw new Error('Required parameter diTypeId was null or undefined when calling handlerDiPluginParamListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (diTypeId !== undefined && diTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>diTypeId, 'diTypeId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/di-plugin-param/list`;
        return this.httpClient.request<DiPluginParams>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a DI Plugin Param
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param diPluginParam 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDiPluginParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, diPluginParam: DiPluginParam, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDiPluginParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, diPluginParam: DiPluginParam, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDiPluginParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, diPluginParam: DiPluginParam, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDiPluginParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, diPluginParam: DiPluginParam, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDiPluginParamPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDiPluginParamPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDiPluginParamPost.');
        }
        if (diPluginParam === null || diPluginParam === undefined) {
            throw new Error('Required parameter diPluginParam was null or undefined when calling handlerDiPluginParamPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/di-plugin-param`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: diPluginParam,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Di Type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDiTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDiTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDiTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDiTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerDiTypeDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDiTypeDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDiTypeDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDiTypeDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/di-type`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Di Type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDiTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<DiType>;
    public handlerDiTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<DiType>>;
    public handlerDiTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<DiType>>;
    public handlerDiTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerDiTypeGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDiTypeGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDiTypeGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDiTypeGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/di-type`;
        return this.httpClient.request<DiType>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all di types
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDiTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<DiTypes>;
    public handlerDiTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<DiTypes>>;
    public handlerDiTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<DiTypes>>;
    public handlerDiTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerDiTypeListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerDiTypeListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDiTypeListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDiTypeListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDiTypeListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerDiTypeListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/di-type/list`;
        return this.httpClient.request<DiTypes>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Di Type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param diType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDiTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, diType: DiType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDiTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, diType: DiType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDiTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, diType: DiType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDiTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, diType: DiType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDiTypePatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDiTypePatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDiTypePatch.');
        }
        if (diType === null || diType === undefined) {
            throw new Error('Required parameter diType was null or undefined when calling handlerDiTypePatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/di-type`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: diType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Di Type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param diType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerDiTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, diType: DiType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerDiTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, diType: DiType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerDiTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, diType: DiType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerDiTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, diType: DiType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerDiTypePost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerDiTypePost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerDiTypePost.');
        }
        if (diType === null || diType === undefined) {
            throw new Error('Required parameter diType was null or undefined when calling handlerDiTypePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/di-type`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: diType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Measure
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerMeasureDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerMeasureDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerMeasureDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerMeasureDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerMeasureDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerMeasureDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerMeasureDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerMeasureDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/measure`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Measure
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerMeasureGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Measure>;
    public handlerMeasureGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Measure>>;
    public handlerMeasureGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Measure>>;
    public handlerMeasureGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerMeasureGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerMeasureGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerMeasureGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerMeasureGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/measure`;
        return this.httpClient.request<Measure>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all measures
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerMeasureListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Measures>;
    public handlerMeasureListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Measures>>;
    public handlerMeasureListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Measures>>;
    public handlerMeasureListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerMeasureListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerMeasureListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerMeasureListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerMeasureListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerMeasureListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerMeasureListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/measure/list`;
        return this.httpClient.request<Measures>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Measure
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param measure 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerMeasurePatch(xUser: string, xSpaceId: string, xSpaceRole: string, measure: Measure, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerMeasurePatch(xUser: string, xSpaceId: string, xSpaceRole: string, measure: Measure, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerMeasurePatch(xUser: string, xSpaceId: string, xSpaceRole: string, measure: Measure, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerMeasurePatch(xUser: string, xSpaceId: string, xSpaceRole: string, measure: Measure, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerMeasurePatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerMeasurePatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerMeasurePatch.');
        }
        if (measure === null || measure === undefined) {
            throw new Error('Required parameter measure was null or undefined when calling handlerMeasurePatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/measure`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: measure,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Measure
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param measure 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerMeasurePost(xUser: string, xSpaceId: string, xSpaceRole: string, measure: Measure, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerMeasurePost(xUser: string, xSpaceId: string, xSpaceRole: string, measure: Measure, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerMeasurePost(xUser: string, xSpaceId: string, xSpaceRole: string, measure: Measure, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerMeasurePost(xUser: string, xSpaceId: string, xSpaceRole: string, measure: Measure, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerMeasurePost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerMeasurePost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerMeasurePost.');
        }
        if (measure === null || measure === undefined) {
            throw new Error('Required parameter measure was null or undefined when calling handlerMeasurePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/measure`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: measure,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete param type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerParamTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerParamTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerParamTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerParamTypeDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerParamTypeDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerParamTypeDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerParamTypeDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerParamTypeDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/param-type`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one param-type
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerParamTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ParamType>;
    public handlerParamTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ParamType>>;
    public handlerParamTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ParamType>>;
    public handlerParamTypeGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerParamTypeGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerParamTypeGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerParamTypeGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerParamTypeGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/param-type`;
        return this.httpClient.request<ParamType>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all param types
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerParamTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ParamTypes>;
    public handlerParamTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ParamTypes>>;
    public handlerParamTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ParamTypes>>;
    public handlerParamTypeListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerParamTypeListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerParamTypeListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerParamTypeListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerParamTypeListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerParamTypeListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerParamTypeListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/param-type/list`;
        return this.httpClient.request<ParamTypes>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a param type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param paramType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerParamTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, paramType: ParamType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerParamTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, paramType: ParamType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerParamTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, paramType: ParamType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerParamTypePatch(xUser: string, xSpaceId: string, xSpaceRole: string, paramType: ParamType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerParamTypePatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerParamTypePatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerParamTypePatch.');
        }
        if (paramType === null || paramType === undefined) {
            throw new Error('Required parameter paramType was null or undefined when calling handlerParamTypePatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/param-type`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: paramType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a param type
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param paramType 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerParamTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, paramType: ParamType, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerParamTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, paramType: ParamType, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerParamTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, paramType: ParamType, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerParamTypePost(xUser: string, xSpaceId: string, xSpaceRole: string, paramType: ParamType, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerParamTypePost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerParamTypePost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerParamTypePost.');
        }
        if (paramType === null || paramType === undefined) {
            throw new Error('Required parameter paramType was null or undefined when calling handlerParamTypePost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/param-type`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: paramType,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Plugin
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerPluginDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerPluginDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerPluginDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerPluginDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerPluginDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerPluginDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerPluginDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerPluginDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/plugin`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Plugin
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerPluginGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Plugin>;
    public handlerPluginGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Plugin>>;
    public handlerPluginGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Plugin>>;
    public handlerPluginGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerPluginGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerPluginGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerPluginGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerPluginGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/plugin`;
        return this.httpClient.request<Plugin>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all plugins
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerPluginListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Plugins>;
    public handlerPluginListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Plugins>>;
    public handlerPluginListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Plugins>>;
    public handlerPluginListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerPluginListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerPluginListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerPluginListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerPluginListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerPluginListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerPluginListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/plugin/list`;
        return this.httpClient.request<Plugins>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Plugin
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param plugin 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerPluginPatch(xUser: string, xSpaceId: string, xSpaceRole: string, plugin: Plugin, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerPluginPatch(xUser: string, xSpaceId: string, xSpaceRole: string, plugin: Plugin, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerPluginPatch(xUser: string, xSpaceId: string, xSpaceRole: string, plugin: Plugin, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerPluginPatch(xUser: string, xSpaceId: string, xSpaceRole: string, plugin: Plugin, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerPluginPatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerPluginPatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerPluginPatch.');
        }
        if (plugin === null || plugin === undefined) {
            throw new Error('Required parameter plugin was null or undefined when calling handlerPluginPatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/plugin`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: plugin,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Plugin
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param plugin 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerPluginPost(xUser: string, xSpaceId: string, xSpaceRole: string, plugin: Plugin, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerPluginPost(xUser: string, xSpaceId: string, xSpaceRole: string, plugin: Plugin, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerPluginPost(xUser: string, xSpaceId: string, xSpaceRole: string, plugin: Plugin, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerPluginPost(xUser: string, xSpaceId: string, xSpaceRole: string, plugin: Plugin, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerPluginPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerPluginPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerPluginPost.');
        }
        if (plugin === null || plugin === undefined) {
            throw new Error('Required parameter plugin was null or undefined when calling handlerPluginPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/plugin`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: plugin,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete project
     * @param id Project identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerProjectDelete(id: string, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerProjectDelete(id: string, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerProjectDelete(id: string, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerProjectDelete(id: string, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerProjectDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerProjectDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerProjectDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerProjectDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/project`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one project
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param id Project identifier
     * @param key Project key
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerProjectGet(xUser: string, xSpaceId: string, xSpaceRole: string, id?: string, key?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Project>;
    public handlerProjectGet(xUser: string, xSpaceId: string, xSpaceRole: string, id?: string, key?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Project>>;
    public handlerProjectGet(xUser: string, xSpaceId: string, xSpaceRole: string, id?: string, key?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Project>>;
    public handlerProjectGet(xUser: string, xSpaceId: string, xSpaceRole: string, id?: string, key?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerProjectGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerProjectGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerProjectGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }
        if (key !== undefined && key !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>key, 'key');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/project`;
        return this.httpClient.request<Project>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all projects
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerProjectListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Projects>;
    public handlerProjectListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Projects>>;
    public handlerProjectListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Projects>>;
    public handlerProjectListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerProjectListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerProjectListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerProjectListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerProjectListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerProjectListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/list`;
        return this.httpClient.request<Projects>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Project Param
     * @param projectId projectId for filtering
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerProjectParamDelete(projectId: string, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerProjectParamDelete(projectId: string, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerProjectParamDelete(projectId: string, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerProjectParamDelete(projectId: string, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerProjectParamDelete.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerProjectParamDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerProjectParamDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerProjectParamDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerProjectParamDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/project-param`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Project Param
     * @param projectId projectId for filtering
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerProjectParamGet(projectId: string, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ProjectParam>;
    public handlerProjectParamGet(projectId: string, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ProjectParam>>;
    public handlerProjectParamGet(projectId: string, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ProjectParam>>;
    public handlerProjectParamGet(projectId: string, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerProjectParamGet.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerProjectParamGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerProjectParamGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerProjectParamGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerProjectParamGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/project-param`;
        return this.httpClient.request<ProjectParam>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Project Params
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerProjectParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ProjectParams>;
    public handlerProjectParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ProjectParams>>;
    public handlerProjectParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ProjectParams>>;
    public handlerProjectParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerProjectParamListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerProjectParamListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerProjectParamListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerProjectParamListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerProjectParamListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerProjectParamListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/project-param/list`;
        return this.httpClient.request<ProjectParams>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Project Param
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectParam 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerProjectParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, projectParam: ProjectParam, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerProjectParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, projectParam: ProjectParam, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerProjectParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, projectParam: ProjectParam, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerProjectParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, projectParam: ProjectParam, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerProjectParamPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerProjectParamPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerProjectParamPost.');
        }
        if (projectParam === null || projectParam === undefined) {
            throw new Error('Required parameter projectParam was null or undefined when calling handlerProjectParamPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/project-param`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: projectParam,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a project
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param project 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerProjectPatch(xUser: string, xSpaceId: string, xSpaceRole: string, project: Project, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerProjectPatch(xUser: string, xSpaceId: string, xSpaceRole: string, project: Project, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerProjectPatch(xUser: string, xSpaceId: string, xSpaceRole: string, project: Project, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerProjectPatch(xUser: string, xSpaceId: string, xSpaceRole: string, project: Project, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerProjectPatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerProjectPatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerProjectPatch.');
        }
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling handlerProjectPatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/project`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: project,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a project
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param project 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerProjectPost(xUser: string, xSpaceId: string, xSpaceRole: string, project: Project, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerProjectPost(xUser: string, xSpaceId: string, xSpaceRole: string, project: Project, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerProjectPost(xUser: string, xSpaceId: string, xSpaceRole: string, project: Project, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerProjectPost(xUser: string, xSpaceId: string, xSpaceRole: string, project: Project, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerProjectPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerProjectPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerProjectPost.');
        }
        if (project === null || project === undefined) {
            throw new Error('Required parameter project was null or undefined when calling handlerProjectPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/project`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: project,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Save Timer
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSaveTimerDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerSaveTimerDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerSaveTimerDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerSaveTimerDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerSaveTimerDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSaveTimerDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSaveTimerDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSaveTimerDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/save-timer`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Save Timer
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSaveTimerGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<SaveTimer>;
    public handlerSaveTimerGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<SaveTimer>>;
    public handlerSaveTimerGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<SaveTimer>>;
    public handlerSaveTimerGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerSaveTimerGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSaveTimerGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSaveTimerGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSaveTimerGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/save-timer`;
        return this.httpClient.request<SaveTimer>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all save timers
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSaveTimerListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<SaveTimers>;
    public handlerSaveTimerListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<SaveTimers>>;
    public handlerSaveTimerListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<SaveTimers>>;
    public handlerSaveTimerListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerSaveTimerListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerSaveTimerListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSaveTimerListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSaveTimerListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSaveTimerListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerSaveTimerListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/save-timer/list`;
        return this.httpClient.request<SaveTimers>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Save Timer
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param saveTimer 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSaveTimerPatch(xUser: string, xSpaceId: string, xSpaceRole: string, saveTimer: SaveTimer, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerSaveTimerPatch(xUser: string, xSpaceId: string, xSpaceRole: string, saveTimer: SaveTimer, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerSaveTimerPatch(xUser: string, xSpaceId: string, xSpaceRole: string, saveTimer: SaveTimer, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerSaveTimerPatch(xUser: string, xSpaceId: string, xSpaceRole: string, saveTimer: SaveTimer, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSaveTimerPatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSaveTimerPatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSaveTimerPatch.');
        }
        if (saveTimer === null || saveTimer === undefined) {
            throw new Error('Required parameter saveTimer was null or undefined when calling handlerSaveTimerPatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/save-timer`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: saveTimer,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Save Timer
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param saveTimer 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSaveTimerPost(xUser: string, xSpaceId: string, xSpaceRole: string, saveTimer: SaveTimer, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerSaveTimerPost(xUser: string, xSpaceId: string, xSpaceRole: string, saveTimer: SaveTimer, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerSaveTimerPost(xUser: string, xSpaceId: string, xSpaceRole: string, saveTimer: SaveTimer, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerSaveTimerPost(xUser: string, xSpaceId: string, xSpaceRole: string, saveTimer: SaveTimer, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSaveTimerPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSaveTimerPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSaveTimerPost.');
        }
        if (saveTimer === null || saveTimer === undefined) {
            throw new Error('Required parameter saveTimer was null or undefined when calling handlerSaveTimerPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/save-timer`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: saveTimer,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete section
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSectionDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerSectionDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerSectionDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerSectionDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerSectionDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSectionDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSectionDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSectionDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/section`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one section
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSectionGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Section>;
    public handlerSectionGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Section>>;
    public handlerSectionGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Section>>;
    public handlerSectionGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerSectionGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSectionGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSectionGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSectionGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/section`;
        return this.httpClient.request<Section>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all sections
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSectionListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Sections>;
    public handlerSectionListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Sections>>;
    public handlerSectionListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Sections>>;
    public handlerSectionListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerSectionListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerSectionListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSectionListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSectionListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSectionListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerSectionListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/section/list`;
        return this.httpClient.request<Sections>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Section Param
     * @param sectionId sectionId for filtering
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSectionParamDelete(sectionId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerSectionParamDelete(sectionId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerSectionParamDelete(sectionId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerSectionParamDelete(sectionId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling handlerSectionParamDelete.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerSectionParamDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSectionParamDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSectionParamDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSectionParamDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (sectionId !== undefined && sectionId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sectionId, 'sectionId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/section-param`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Section Param
     * @param sectionId sectionId for filtering
     * @param paramId Param identifier
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSectionParamGet(sectionId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<SectionParam>;
    public handlerSectionParamGet(sectionId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<SectionParam>>;
    public handlerSectionParamGet(sectionId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<SectionParam>>;
    public handlerSectionParamGet(sectionId: number, paramId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling handlerSectionParamGet.');
        }
        if (paramId === null || paramId === undefined) {
            throw new Error('Required parameter paramId was null or undefined when calling handlerSectionParamGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSectionParamGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSectionParamGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSectionParamGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (sectionId !== undefined && sectionId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sectionId, 'sectionId');
        }
        if (paramId !== undefined && paramId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>paramId, 'paramId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/section-param`;
        return this.httpClient.request<SectionParam>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all Section Params
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param sectionId sectionId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSectionParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, sectionId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<SectionParams>;
    public handlerSectionParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, sectionId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<SectionParams>>;
    public handlerSectionParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, sectionId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<SectionParams>>;
    public handlerSectionParamListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, sectionId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerSectionParamListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerSectionParamListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSectionParamListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSectionParamListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSectionParamListGet.');
        }
        if (sectionId === null || sectionId === undefined) {
            throw new Error('Required parameter sectionId was null or undefined when calling handlerSectionParamListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (sectionId !== undefined && sectionId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sectionId, 'sectionId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/section-param/list`;
        return this.httpClient.request<SectionParams>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Section Param
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param sectionParam 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSectionParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, sectionParam: SectionParam, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerSectionParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, sectionParam: SectionParam, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerSectionParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, sectionParam: SectionParam, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerSectionParamPost(xUser: string, xSpaceId: string, xSpaceRole: string, sectionParam: SectionParam, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSectionParamPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSectionParamPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSectionParamPost.');
        }
        if (sectionParam === null || sectionParam === undefined) {
            throw new Error('Required parameter sectionParam was null or undefined when calling handlerSectionParamPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/section-param`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: sectionParam,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a section
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param section 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSectionPatch(xUser: string, xSpaceId: string, xSpaceRole: string, section: Section, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerSectionPatch(xUser: string, xSpaceId: string, xSpaceRole: string, section: Section, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerSectionPatch(xUser: string, xSpaceId: string, xSpaceRole: string, section: Section, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerSectionPatch(xUser: string, xSpaceId: string, xSpaceRole: string, section: Section, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSectionPatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSectionPatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSectionPatch.');
        }
        if (section === null || section === undefined) {
            throw new Error('Required parameter section was null or undefined when calling handlerSectionPatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/section`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: section,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a section
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param section 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerSectionPost(xUser: string, xSpaceId: string, xSpaceRole: string, section: Section, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerSectionPost(xUser: string, xSpaceId: string, xSpaceRole: string, section: Section, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerSectionPost(xUser: string, xSpaceId: string, xSpaceRole: string, section: Section, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerSectionPost(xUser: string, xSpaceId: string, xSpaceRole: string, section: Section, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerSectionPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerSectionPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerSectionPost.');
        }
        if (section === null || section === undefined) {
            throw new Error('Required parameter section was null or undefined when calling handlerSectionPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/section`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: section,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Translation
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerTranslationDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerTranslationDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerTranslationDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerTranslationDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerTranslationDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerTranslationDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerTranslationDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerTranslationDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/translation`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Translation
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerTranslationGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Translation>;
    public handlerTranslationGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Translation>>;
    public handlerTranslationGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Translation>>;
    public handlerTranslationGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerTranslationGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerTranslationGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerTranslationGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerTranslationGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/translation`;
        return this.httpClient.request<Translation>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all translations
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param projectId projectId for filtering
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerTranslationListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Translations>;
    public handlerTranslationListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Translations>>;
    public handlerTranslationListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Translations>>;
    public handlerTranslationListGet(limit: number, start: number, xUser: string, xSpaceId: string, xSpaceRole: string, projectId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerTranslationListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerTranslationListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerTranslationListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerTranslationListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerTranslationListGet.');
        }
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling handlerTranslationListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (projectId !== undefined && projectId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>projectId, 'projectId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/translation/list`;
        return this.httpClient.request<Translations>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Translation
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param translation 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerTranslationPatch(xUser: string, xSpaceId: string, xSpaceRole: string, translation: Translation, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerTranslationPatch(xUser: string, xSpaceId: string, xSpaceRole: string, translation: Translation, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerTranslationPatch(xUser: string, xSpaceId: string, xSpaceRole: string, translation: Translation, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerTranslationPatch(xUser: string, xSpaceId: string, xSpaceRole: string, translation: Translation, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerTranslationPatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerTranslationPatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerTranslationPatch.');
        }
        if (translation === null || translation === undefined) {
            throw new Error('Required parameter translation was null or undefined when calling handlerTranslationPatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/translation`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: translation,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Translation
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param translation 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerTranslationPost(xUser: string, xSpaceId: string, xSpaceRole: string, translation: Translation, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerTranslationPost(xUser: string, xSpaceId: string, xSpaceRole: string, translation: Translation, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerTranslationPost(xUser: string, xSpaceId: string, xSpaceRole: string, translation: Translation, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerTranslationPost(xUser: string, xSpaceId: string, xSpaceRole: string, translation: Translation, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerTranslationPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerTranslationPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerTranslationPost.');
        }
        if (translation === null || translation === undefined) {
            throw new Error('Required parameter translation was null or undefined when calling handlerTranslationPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/translation`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: translation,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Value View
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerValueViewDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerValueViewDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerValueViewDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerValueViewDelete(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerValueViewDelete.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerValueViewDelete.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerValueViewDelete.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerValueViewDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/value-view`;
        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one Value View
     * @param id Primary identifier (int)
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerValueViewGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ValueView>;
    public handlerValueViewGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ValueView>>;
    public handlerValueViewGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ValueView>>;
    public handlerValueViewGet(id: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling handlerValueViewGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerValueViewGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerValueViewGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerValueViewGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/value-view`;
        return this.httpClient.request<ValueView>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all value views
     * @param limit How many items to return at one time (max 1000)
     * @param start Offset position
     * @param diTypeId Di Type Id
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerValueViewListGet(limit: number, start: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<ValueViews>;
    public handlerValueViewListGet(limit: number, start: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<ValueViews>>;
    public handlerValueViewListGet(limit: number, start: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<ValueViews>>;
    public handlerValueViewListGet(limit: number, start: number, diTypeId: number, xUser: string, xSpaceId: string, xSpaceRole: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling handlerValueViewListGet.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling handlerValueViewListGet.');
        }
        if (diTypeId === null || diTypeId === undefined) {
            throw new Error('Required parameter diTypeId was null or undefined when calling handlerValueViewListGet.');
        }
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerValueViewListGet.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerValueViewListGet.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerValueViewListGet.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (start !== undefined && start !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>start, 'start');
        }
        if (diTypeId !== undefined && diTypeId !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>diTypeId, 'diTypeId');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/value-view/list`;
        return this.httpClient.request<ValueViews>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a Value View
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param valueView 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerValueViewPatch(xUser: string, xSpaceId: string, xSpaceRole: string, valueView: ValueView, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerValueViewPatch(xUser: string, xSpaceId: string, xSpaceRole: string, valueView: ValueView, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerValueViewPatch(xUser: string, xSpaceId: string, xSpaceRole: string, valueView: ValueView, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerValueViewPatch(xUser: string, xSpaceId: string, xSpaceRole: string, valueView: ValueView, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerValueViewPatch.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerValueViewPatch.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerValueViewPatch.');
        }
        if (valueView === null || valueView === undefined) {
            throw new Error('Required parameter valueView was null or undefined when calling handlerValueViewPatch.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/value-view`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: valueView,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Value View
     * @param xUser Authorized user
     * @param xSpaceId Current Space Id
     * @param xSpaceRole Current Space User Role
     * @param valueView 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public handlerValueViewPost(xUser: string, xSpaceId: string, xSpaceRole: string, valueView: ValueView, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public handlerValueViewPost(xUser: string, xSpaceId: string, xSpaceRole: string, valueView: ValueView, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public handlerValueViewPost(xUser: string, xSpaceId: string, xSpaceRole: string, valueView: ValueView, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public handlerValueViewPost(xUser: string, xSpaceId: string, xSpaceRole: string, valueView: ValueView, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (xUser === null || xUser === undefined) {
            throw new Error('Required parameter xUser was null or undefined when calling handlerValueViewPost.');
        }
        if (xSpaceId === null || xSpaceId === undefined) {
            throw new Error('Required parameter xSpaceId was null or undefined when calling handlerValueViewPost.');
        }
        if (xSpaceRole === null || xSpaceRole === undefined) {
            throw new Error('Required parameter xSpaceRole was null or undefined when calling handlerValueViewPost.');
        }
        if (valueView === null || valueView === undefined) {
            throw new Error('Required parameter valueView was null or undefined when calling handlerValueViewPost.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (xUser !== undefined && xUser !== null) {
            localVarHeaders = localVarHeaders.set('X-User', String(xUser));
        }
        if (xSpaceId !== undefined && xSpaceId !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Id', String(xSpaceId));
        }
        if (xSpaceRole !== undefined && xSpaceRole !== null) {
            localVarHeaders = localVarHeaders.set('X-Space-Role', String(xSpaceRole));
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/project/value-view`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: valueView,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
